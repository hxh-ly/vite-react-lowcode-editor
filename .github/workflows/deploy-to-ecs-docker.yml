name: Build, Push to Docker Hub and Deploy to ECS

on:
  push:
    branches: [ "main" ]
  # 上面是工作元数据
env:
  # --- 主要修改在这里 ---
  DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }} # 你的 Docker Hub 用户名
  IMAGE_NAME: ${{ secrets.DOCKERHUB_USERNAME }}/low_code # 你的 Docker Hub 镜像名，如 'myusername/my-frontend-app'
  # --- 修改结束 ---
  CONTAINER_NAME: "container_low_code" # 你的容器名称，如 my-frontend-app
  ECS_HOST: ${{ secrets.ALIYUN_ECS_HOST }} # 你的 ECS 公网 IP
  ECS_USER: ${{ secrets.ALIYUN_ECS_USER }} # 你的 ECS 登录用户，如 deployer

jobs:
  build-and-push:
    runs-on: ubuntu-latest # 最新版本的 Ubuntu 虚拟机上执行这个 Job
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4  #  检出代码

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3  # Buildx 是 Docker 的一个扩展插件，支持更强大的构建功能，如多平台构建

      - name: Log in to Docker Hub
        # --- 主要修改在这里 ---
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }} # 使用 Token 而非密码更安全
        # --- 修改结束 ---

      - name: Extract metadata for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.IMAGE_NAME }} # 直接使用 Docker Hub 镜像名
          tags: |
            type=sha,prefix={{date 'YYYYMMDD'}}-,suffix=-{{sha}}
            type=ref,event=branch
          # 生成镜像标签 这会生成类似 'myusername/myapp:20230915-a1b2c3d' 和 'myusername/myapp:main' 的标签

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
            # 构建并推送镜像
  deploy: # 部署任务
    needs: build-and-push # needs: build-and-push：确保只有在前一个构建任务成功完成后，部署任务才会开始。
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'

    steps: #通过 SSH 部署
      - name: Deploy to ECS via SSH
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ env.ECS_HOST }}
          username: ${{ env.ECS_USER }}
          key: ${{ secrets.ALIYUN_ECS_SSH_KEY }}
          script: |
            # --- 主要修改在这里 ---
            # 如果使用私有仓库，需要在服务器上登录 Docker Hub
            # 如果是公共仓库，则无需登录
            echo "${{ secrets.DOCKERHUB_TOKEN }}" | sudo docker login -u "${{ secrets.DOCKERHUB_USERNAME }}" --password-stdin

            # 停止并移除当前正在运行的容器
            sudo docker stop ${{ env.CONTAINER_NAME }} || true
            sudo docker rm ${{ env.CONTAINER_NAME }} || true

            # 拉取最新的镜像（现在从 Docker Hub 拉取）
            sudo docker pull ${{ env.IMAGE_NAME }}:main

            # 运行一个新的容器
            # --restart=always 确保容器在退出时自动重启，包括服务器重启后
            # --health-cmd 使用wget进行健康检查（nginx:alpine包含wget）
            # --health-interval 设置健康检查间隔为30秒
            # --health-timeout 设置健康检查超时为5秒
            # --health-retries 设置健康检查失败重试次数为3次
            # --memory 和 --cpus 设置资源限制，防止资源耗尽
            # --log-opt max-size/max-file 配置日志管理，防止日志过大
            sudo docker run -d \
              --name ${{ env.CONTAINER_NAME }} \
              -p 80:80 \
              --restart=always \
              --health-cmd="wget --no-verbose --tries=1 --spider http://localhost:80/project/lowcode/ || exit 1" \
              --health-interval=30s \
              --health-timeout=5s \
              --health-retries=3 \
              --memory="512m" \
              --cpus="0.5" \
              --log-opt max-size=10m \
              --log-opt max-file=3 \
              ${{ env.IMAGE_NAME }}:main
            # --- 修改结束 ---

            # （可选）清理不再使用的旧镜像，避免磁盘空间占用
            sudo docker image prune -af
            
            # 确保Docker服务开机自启
            # 这一步很重要，确保ECS服务器重启后Docker服务能自动启动
            # docker容器的--restart=always配置依赖于Docker服务本身能启动
            sudo systemctl enable docker.service
            
            # 额外的保障措施：检查Docker服务状态并记录日志
            echo "检查Docker服务状态..."
            sudo systemctl status docker.service || true
            
            # 如果Docker服务未运行，手动启动它
            # 这是一个重要的保障措施，确保即使Docker服务没有运行，部署也能继续
            echo "检查Docker服务是否在运行..."
            if ! sudo systemctl is-active --quiet docker.service; then
              echo "Docker服务未运行，正在启动..."
              sudo systemctl start docker.service || echo "Docker服务启动失败，请检查系统配置"
              # 启动后等待几秒钟确保服务稳定
              sleep 5
            fi
            
            # 查看容器重启策略配置是否正确
            echo "检查容器重启策略..."
            docker inspect --format '{{ .HostConfig.RestartPolicy.Name }}' ${{ env.CONTAINER_NAME }} || true
            
            # 记录Docker版本信息，便于排查问题
            docker --version
            
            # 为容器添加额外的自动启动保障
            # 如果容器创建成功但未运行，尝试启动它
            docker start ${{ env.CONTAINER_NAME }} || echo "容器已在运行或启动失败"
            
            # 查看当前运行的容器，确认部署成功
            docker ps
            
            # 记录系统资源状态，便于排查资源不足问题
            echo "系统内存状态："
            free -h
            
            echo "磁盘空间状态："
            df -h